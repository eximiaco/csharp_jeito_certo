---
description: Regras de Testes do Projeto GymErp
globs:
alwaysApply: true
---

# Testing Rules - GymErp Project

- **Regras validas apenas para projeto modernizado contido na pasta src**:
- **NUNCA** aplique essas regras para o projeto legado, dentro da pasta legacy

## üèóÔ∏è Arquitetura de Testes

### Organiza√ß√£o por Contextos
```
src/GymErp.IntegrationTests/
‚îú‚îÄ‚îÄ Infrastructure/              # Infraestrutura compartilhada
‚îÇ   ‚îú‚îÄ‚îÄ IntegrationTestBase.cs   # Classe base para testes de integra√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ EfDbContextAccessor.cs   # Acesso ao DbContext para testes
‚îú‚îÄ‚îÄ Subscriptions/               # Testes do contexto Subscriptions
‚îÇ   ‚îú‚îÄ‚îÄ AddNewEnrollment/
‚îÇ   ‚îú‚îÄ‚îÄ CancelEnrollment/
‚îÇ   ‚îî‚îÄ‚îÄ EnrollmentStateTests.cs
‚îú‚îÄ‚îÄ Financial/                   # Testes do contexto Financial
‚îÇ   ‚îî‚îÄ‚îÄ ProcessCharging/
‚îú‚îÄ‚îÄ Orchestration/               # Testes do contexto Orchestration
‚îÇ   ‚îú‚îÄ‚îÄ NewEnrollmentFlow/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SimpleWorkflowTests.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TestHelpers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StepTests/
‚îÇ   ‚îú‚îÄ‚îÄ CancelEnrollmentFlow/
‚îÇ   ‚îî‚îÄ‚îÄ EnrollmentOrchestrator/ # Testes do EnrollmentOrchestrator
‚îÇ       ‚îú‚îÄ‚îÄ HandlerTests.cs
‚îÇ       ‚îú‚îÄ‚îÄ EndpointTests.cs
‚îÇ       ‚îî‚îÄ‚îÄ TestHelpers/
‚îÇ           ‚îî‚îÄ‚îÄ TestDataBuilder.cs
‚îî‚îÄ‚îÄ Masterclass/sample04/src/GymErp.UnitTests/  # Testes unit√°rios
```

## üìã Regras Gerais

### üéØ Princ√≠pios Fundamentais de Testes

#### ‚úÖ DO - Premissas Gerais
- **SEMPRE** prefira testes de integra√ß√£o que testam comportamento real
- **SEMPRE** use servi√ßos reais com configura√ß√µes mockadas quando poss√≠vel
- **SEMPRE** teste cen√°rios de falha para servi√ßos externos
- **SEMPRE** use mocks do pr√≥prio framework (ex: Flurl) para testes HTTP
- **SEMPRE** mantenha testes simples e focados no comportamento

#### ‚ùå DON'T - Premissas Gerais
- **NUNCA** crie interfaces apenas para facilitar testes
- **NUNCA** use mocks de classes concretas que n√£o s√£o virtuais
- **NUNCA** teste chamadas HTTP reais em testes de integra√ß√£o (exceto casos expl√≠citos)
- **NUNCA** adicione complexidade acidental por conta dos testes
- **NUNCA** ignore o tratamento de erros de servi√ßos externos

### üåê Testes HTTP: Quando Usar Mocks vs Servi√ßos Reais

#### ‚úÖ DO - Use Mocks do Framework (Flurl)
- **SEMPRE** para testes de integra√ß√£o que validam comportamento interno
- **SEMPRE** para testes de cen√°rios de falha (timeout, erro 500, etc.)
- **SEMPRE** para testes de orquestra√ß√£o e l√≥gica de decis√£o
- **SEMPRE** para testes que n√£o dependem de servi√ßos externos espec√≠ficos

#### ‚úÖ DO - Use Servi√ßos Reais (Casos Expl√≠citos)
- **APENAS** para testes end-to-end que validam integra√ß√£o completa
- **APENAS** para testes de contratos de API com servi√ßos externos
- **APENAS** para testes de performance e carga
- **APENAS** quando explicitamente necess√°rio para validar comportamento real

#### ‚ùå DON'T - Testes HTTP
- **NUNCA** use servi√ßos reais para testes de integra√ß√£o internos
- **NUNCA** ignore configura√ß√£o de timeout e retry policies
- **NUNCA** teste cen√°rios de sucesso quando servi√ßos externos n√£o est√£o dispon√≠veis

### ‚úÖ DO - Boas Pr√°ticas

#### Estrutura de Arquivos
- **SEMPRE** organize testes por contexto de dom√≠nio (Subscriptions, Financial, Orchestration)
- **SEMPRE** use `IntegrationTestBase` para testes que envolvem infraestrutura
- **SEMPRE** crie pastas separadas para cada feature dentro do contexto
- **SEMPRE** use nomenclatura `[Feature]Tests.cs` para arquivos de teste

#### Nomenclatura de Testes
- **SEMPRE** use padr√£o `MethodName_ShouldExpectedBehavior_WhenCondition`
- **SEMPRE** use `[Fact]` para testes √∫nicos e `[Theory]` para testes parametrizados
- **SEMPRE** use `InlineData` para cen√°rios de teste com dados diferentes

#### Setup e Teardown
- **SEMPRE** implemente `IAsyncLifetime` para testes que usam `IntegrationTestBase`
- **SEMPRE** chame `await base.InitializeAsync()` no setup personalizado
- **SEMPRE** chame `await base.DisposeAsync()` no cleanup personalizado
- **SEMPRE** dispose recursos criados manualmente no `DisposeAsync`

#### Assertions
- **SEMPRE** use `FluentAssertions` para assertions mais leg√≠veis
- **SEMPRE** verifique tanto `IsSuccess` quanto `IsFailure` em Result patterns
- **SEMPRE** valide dados espec√≠ficos ap√≥s opera√ß√µes de cria√ß√£o/atualiza√ß√£o
- **SEMPRE** use `Should().BeCloseTo()` para compara√ß√µes de DateTime

### ‚ùå DON'T - Anti-patterns

#### Estrutura de Arquivos
- **NUNCA** misture testes de contextos diferentes no mesmo arquivo
- **NUNCA** coloque testes de workflow no contexto de dom√≠nio espec√≠fico
- **NUNCA** crie depend√™ncias circulares entre classes de teste

#### Setup e Configura√ß√£o
- **NUNCA** use mocks desnecess√°rios em testes de integra√ß√£o
- **NUNCA** compartilhe estado entre testes (cada teste deve ser independente)
- **NUNCA** deixe containers Docker rodando ap√≥s os testes

#### Assertions
- **NUNCA** use `Assert.True(true)` como placeholder
- **NUNCA** ignore exce√ß√µes n√£o tratadas nos testes
- **NUNCA** fa√ßa assertions em dados que n√£o foram explicitamente testados

## üéØ Tipos de Testes por Contexto

### Contexto Subscriptions

#### ‚úÖ DO
```csharp
public class HandlerTests : IntegrationTestBase, IAsyncLifetime
{
    private Handler _handler = null!;
    private EnrollmentRepository _enrollmentRepository = null!;
    private IUnitOfWork _unitOfWork = null!;
    private EfDbContextAccessor<SubscriptionsDbContext> _dbContextAccessor = null!;

    public new async Task InitializeAsync()
    {
        await base.InitializeAsync();
        _dbContextAccessor = new EfDbContextAccessor<SubscriptionsDbContext>(_dbContext);
        _enrollmentRepository = new EnrollmentRepository(_dbContextAccessor);
        _unitOfWork = new UnitOfWork(_dbContext);
        _handler = new Handler(_enrollmentRepository, _unitOfWork, CancellationToken.None);
    }

    [Fact]
    public async Task HandleAsync_ShouldCreateEnrollment_WhenValidRequest()
    {
        // Arrange
        var request = new Request
        {
            Name = "Jo√£o da Silva Santos",
            Email = "joao.silva@email.com",
            // ... outros campos
        };

        // Act
        var result = await _handler.HandleAsync(request);

        // Assert
        result.IsSuccess.Should().BeTrue();
        var enrollment = await _dbContext.Enrollments.FindAsync(result.Value);
        enrollment.Should().NotBeNull();
        enrollment!.Client.Name.Should().Be(request.Name);
    }

    [Theory]
    [InlineData("", "email@test.com", "11999999999", "Nome n√£o pode ser vazio")]
    [InlineData("Jo√£o S.", "email@test.com", "11999999999", "Nome deve ter pelo menos 10 caracteres")]
    public async Task HandleAsync_ShouldReturnFailure_WhenInvalidRequest(
        string name, string email, string phone, string expectedError)
    {
        // Arrange
        var request = new Request { Name = name, Email = email, Phone = phone };

        // Act
        var result = await _handler.HandleAsync(request);

        // Assert
        result.IsFailure.Should().BeTrue();
        result.Error.Should().Be(expectedError);
    }
}
```

#### ‚ùå DON'T
- **NUNCA** teste valida√ß√µes de dom√≠nio em testes de integra√ß√£o (use testes unit√°rios)
- **NUNCA** fa√ßa testes de integra√ß√£o para l√≥gica pura de neg√≥cio
- **NUNCA** ignore verifica√ß√£o de eventos publicados no Kafka

### Contexto Financial

#### ‚úÖ DO
```csharp
public class HandlerTests : IntegrationTestBase
{
    private FinancialHandler _handler = null!;
    private IBroker _broker = null!;

    protected override async Task SetupDatabase()
    {
        await base.SetupDatabase();
        
        _handler = new FinancialHandler(new NullLogger<FinancialHandler>());
        _broker = _serviceProvider.GetRequiredService<IBroker>();
    }

    [Fact]
    public async Task HandleAsync_ShouldProcessEvent_WhenValidEnrollmentCreated()
    {
        // Arrange
        var enrollmentId = Guid.NewGuid();
        var enrollmentCreatedEvent = new EnrollmentCreatedEvent(enrollmentId);

        // Act
        await _handler.HandleAsync(enrollmentCreatedEvent, CancellationToken.None);

        // Assert
        // Verificar processamento sem exce√ß√µes
        true.Should().BeTrue(); // Placeholder para valida√ß√£o futura
    }
}
```

#### ‚ùå DON'T
- **NUNCA** teste l√≥gica de neg√≥cio complexa em testes de mensageria
- **NUNCA** ignore configura√ß√£o do broker Kafka nos testes
- **NUNCA** fa√ßa assertions em logs (n√£o s√£o test√°veis)

### Contexto Orchestration

#### ‚úÖ DO
```csharp
public class SimpleWorkflowTests : IntegrationTestBase, IAsyncLifetime
{
    private IWorkflowHost _workflowHost = null!;

    public new async Task InitializeAsync()
    {
        await base.InitializeAsync();
        
        // Configurar WorkflowCore para testes
        var services = new ServiceCollection();
        services.AddLogging();
        services.AddWorkflow();
        
        // Registrar workflow e steps
        services.AddTransient<MainWorkflow>();
        services.AddTransient<AddEnrollmentStep>();
        // ... outros steps
        
        var serviceProvider = services.BuildServiceProvider();
        _workflowHost = serviceProvider.GetRequiredService<IWorkflowHost>();
        
        // CR√çTICO: Registrar o workflow no host
        _workflowHost.RegisterWorkflow<MainWorkflow, NewEnrollmentFlowData>();
        _workflowHost.Start();
    }

    [Fact]
    public async Task Workflow_ShouldStartSuccessfully_WhenValidData()
    {
        // Arrange
        var data = TestDataBuilder.CreateValidData().Build();

        // Act
        var workflowId = await _workflowHost.StartWorkflow("new-enrollment-workflow", data);

        // Assert
        workflowId.Should().NotBeEmpty();
    }

    [Fact]
    public async Task Workflow_ShouldThrowException_WhenInvalidWorkflowId()
    {
        // Arrange
        var data = TestDataBuilder.CreateValidData().Build();

        // Act & Assert
        var act = async () => await _workflowHost.StartWorkflow("invalid-workflow-id", data);
        await act.Should().ThrowAsync<WorkflowNotRegisteredException>();
    }
}
```

#### ‚ùå DON'T
- **NUNCA** esque√ßa de registrar workflows com `RegisterWorkflow<>()`
- **NUNCA** teste steps individuais em testes de workflow (use testes unit√°rios)
- **NUNCA** ignore o lifecycle do `IWorkflowHost` (Start/Stop)

### Contexto Orchestration - EnrollmentOrchestrator

#### ‚úÖ DO - Princ√≠pios de Teste de Orquestra√ß√£o
- **SEMPRE** teste a l√≥gica de decis√£o do orquestrador (qual sistema usar baseado no tipo de plano)
- **SEMPRE** teste cen√°rios de falha quando servi√ßos externos n√£o est√£o dispon√≠veis
- **SEMPRE** valide que o Result pattern est√° sendo usado corretamente
- **SEMPRE** teste o comportamento de fallback quando adapters falham
- **SEMPRE** use configura√ß√µes mockadas para URLs de servi√ßos externos

#### ‚ùå DON'T - EnrollmentOrchestrator
- **NUNCA** teste cen√°rios de sucesso quando servi√ßos externos n√£o est√£o dispon√≠veis
- **NUNCA** ignore o tratamento de erros de conectividade
- **NUNCA** teste chamadas HTTP reais em testes de integra√ß√£o
- **NUNCA** crie interfaces apenas para facilitar testes

## üõ†Ô∏è Test Helpers e Builders

### ‚úÖ DO - TestDataBuilder Pattern
```csharp
public class TestDataBuilder
{
    private NewEnrollmentFlowData _data;

    public TestDataBuilder()
    {
        _data = new NewEnrollmentFlowData();
    }

    public static TestDataBuilder CreateValidData()
    {
        return new TestDataBuilder()
            .WithClientId(Guid.NewGuid())
            .WithPlanId(Guid.NewGuid())
            .WithName("Jo√£o da Silva Santos")
            .WithEmail("joao.silva@email.com");
    }

    public static TestDataBuilder CreateWithInvalidClient()
    {
        return new TestDataBuilder()
            .WithClientId(Guid.Empty) // Cliente inv√°lido
            .WithPlanId(Guid.NewGuid());
    }

    public TestDataBuilder WithClientId(Guid clientId)
    {
        _data.ClientId = clientId;
        return this;
    }

    public NewEnrollmentFlowData Build()
    {
        return _data;
    }
}
```

#### ‚ùå DON'T
- **NUNCA** crie dados de teste inline sem builders para casos complexos
- **NUNCA** use dados hardcoded quando h√° m√∫ltiplos cen√°rios
- **NUNCA** ignore cen√°rios de falha nos builders

## üîß Configura√ß√£o de Infraestrutura

### ‚úÖ DO - IntegrationTestBase Usage
```csharp
public abstract class IntegrationTestBase : IAsyncLifetime
{
    protected readonly PostgreSqlContainer _postgresContainer;
    protected readonly KafkaContainer _kafkaContainer;
    protected SubscriptionsDbContext _dbContext = null!;
    protected IServiceBus _serviceBus = null!;
    protected IIntegrationSpy _spy = null!;
    protected ServiceProvider _serviceProvider = null!;

    protected IntegrationTestBase()
    {
        _postgresContainer = new PostgreSqlBuilder()
            .WithImage("postgres:latest")
            .WithDatabase("gym_erp_test")
            .WithUsername("postgres")
            .WithPassword("postgres")
            .Build();

        _kafkaContainer = new KafkaBuilder()
            .WithImage("confluentinc/cp-kafka:latest")
            .WithEnvironment("KAFKA_AUTO_CREATE_TOPICS_ENABLE", "true")
            .Build();
    }

    public virtual async Task InitializeAsync()
    {
        await _postgresContainer.StartAsync();
        await _kafkaContainer.StartAsync();
        
        // Setup DbContext
        var options = new DbContextOptionsBuilder<SubscriptionsDbContext>()
            .UseNpgsql(_postgresContainer.GetConnectionString())
            .Options;
        
        _dbContext = new SubscriptionsDbContext(options);
        await _dbContext.Database.EnsureCreatedAsync();
        
        // Setup Silverback
        await SetupSilverback();
    }
}
```

### ‚ùå DON'T
- **NUNCA** configure containers Docker manualmente em cada teste
- **NUNCA** ignore cleanup de recursos nos testes
- **NUNCA** use banco de dados compartilhado entre testes

## üì¶ Depend√™ncias e Packages

### ‚úÖ DO - Packages Necess√°rios
```xml
<PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0" />
<PackageReference Include="xunit" Version="2.9.2" />
<PackageReference Include="FluentAssertions" Version="6.12.2" />
<PackageReference Include="Testcontainers" Version="4.0.0" />
<PackageReference Include="Testcontainers.PostgreSql" Version="4.0.0" />
<PackageReference Include="Testcontainers.Kafka" Version="4.0.0" />
<PackageReference Include="Silverback.Integration.Testing" Version="4.5.0" />
<PackageReference Include="Moq" Version="4.20.72" />
```

### ‚ùå DON'T
- **NUNCA** adicione packages desnecess√°rios para testes
- **NUNCA** use vers√µes antigas de TestContainers
- **NUNCA** misture frameworks de teste (use apenas xUnit)

## üöÄ Execu√ß√£o de Testes

### ‚úÖ DO - Comandos Recomendados
```bash
# Executar todos os testes
dotnet test

# Executar testes espec√≠ficos por filtro
dotnet test --filter "SimpleWorkflowTests"
dotnet test --filter "Subscriptions"
dotnet test --filter "Orchestration"

# Executar com verbosidade
dotnet test --verbosity normal

# Executar testes em paralelo (cuidado com recursos)
dotnet test --parallel
```

### ‚ùå DON'T
- **NUNCA** execute testes de integra√ß√£o em paralelo sem isolamento adequado
- **NUNCA** ignore falhas de timeout nos testes
- **NUNCA** deixe containers Docker rodando ap√≥s execu√ß√£o

## üìä Cobertura e M√©tricas

### ‚úÖ DO - Estrat√©gia de Cobertura
- **Testes Unit√°rios**: L√≥gica de dom√≠nio, valida√ß√µes, business rules
- **Testes de Integra√ß√£o**: Handlers, workflows, mensageria, banco de dados
- **Testes End-to-End**: Fluxos completos via API (quando necess√°rio)

### ‚ùå DON'T
- **NUNCA** teste c√≥digo de infraestrutura que n√£o √© seu (Entity Framework, etc.)
- **NUNCA** force 100% de cobertura em c√≥digo trivial
- **NUNCA** ignore testes de cen√°rios de falha

## üéØ Padr√µes Espec√≠ficos por Tecnologia

### WorkflowCore Tests
```csharp
// ‚úÖ DO - Configura√ß√£o correta
services.AddWorkflow();
services.AddTransient<MainWorkflow>();
services.AddTransient<StepImplementation>();

// CR√çTICO: Registrar workflow
_workflowHost.RegisterWorkflow<MainWorkflow, WorkflowData>();
_workflowHost.Start();

// ‚úÖ DO - Teste de exce√ß√£o
var act = async () => await _workflowHost.StartWorkflow("invalid-id", data);
await act.Should().ThrowAsync<WorkflowNotRegisteredException>();
```

### Silverback/Kafka Tests
```csharp
// ‚úÖ DO - Verifica√ß√£o de mensagens
await VerifyMessagePublishedInKafkaTopic<EnrollmentCreatedEvent>(
    "enrollment-events", 
    1);

// ‚úÖ DO - Verifica√ß√£o de n√£o publica√ß√£o
VerifyNoMessagesPublished();
```

### Entity Framework Tests
```csharp
// ‚úÖ DO - Verifica√ß√£o de persist√™ncia
var enrollment = await _dbContext.Enrollments.FindAsync(result.Value);
enrollment.Should().NotBeNull();
enrollment!.Client.Name.Should().Be(request.Name);

// ‚úÖ DO - Cleanup
await _dbContext.Database.EnsureDeletedAsync();
```

### Servi√ßos HTTP com Flurl Tests

#### ‚úÖ DO - Princ√≠pios para Testes HTTP
- **SEMPRE** use servi√ßos reais com configura√ß√µes mockadas (URLs que n√£o existem)
- **SEMPRE** teste cen√°rios de falha quando servi√ßos externos n√£o est√£o dispon√≠veis
- **SEMPRE** valide que o Result pattern est√° sendo usado corretamente
- **SEMPRE** use mocks do pr√≥prio Flurl para testes HTTP quando necess√°rio
- **SEMPRE** teste o tratamento de erros de conectividade

#### ‚ùå DON'T - Servi√ßos HTTP
- **NUNCA** crie interfaces apenas para facilitar testes de servi√ßos HTTP
- **NUNCA** use mocks de classes concretas que fazem chamadas HTTP
- **NUNCA** teste cen√°rios de sucesso quando servi√ßos externos n√£o est√£o dispon√≠veis
- **NUNCA** ignore o tratamento de erros de conectividade
- **NUNCA** use URLs reais em testes de integra√ß√£o (exceto casos expl√≠citos)

---

## üìù Resumo das Regras Cr√≠ticas

### üéØ Princ√≠pios Fundamentais
1. **SEMPRE** prefira testes de integra√ß√£o que testam comportamento real
2. **SEMPRE** use servi√ßos reais com configura√ß√µes mockadas quando poss√≠vel
3. **SEMPRE** teste cen√°rios de falha para servi√ßos externos
4. **SEMPRE** use mocks do pr√≥prio framework (ex: Flurl) para testes HTTP
5. **NUNCA** crie interfaces apenas para facilitar testes
6. **NUNCA** use mocks de classes concretas que n√£o s√£o virtuais
7. **NUNCA** teste chamadas HTTP reais em testes de integra√ß√£o (exceto casos expl√≠citos)
8. **NUNCA** adicione complexidade acidental por conta dos testes

### üèóÔ∏è Regras de Infraestrutura
9. **SEMPRE** use `IntegrationTestBase` para testes de infraestrutura
10. **SEMPRE** implemente `IAsyncLifetime` para lifecycle correto
11. **SEMPRE** registre workflows com `RegisterWorkflow<>()` em testes de orchestration
12. **SEMPRE** use `TestDataBuilder` para dados complexos
13. **SEMPRE** valide eventos publicados no Kafka
14. **NUNCA** compartilhe estado entre testes
15. **NUNCA** ignore cleanup de recursos
16. **NUNCA** teste l√≥gica de dom√≠nio em testes de integra√ß√£o

### üéØ Regras Espec√≠ficas para Orquestra√ß√£o
- **SEMPRE** teste a l√≥gica de decis√£o do orquestrador (qual sistema usar)
- **SEMPRE** valide que planos mensais s√£o direcionados para o sistema legado
- **SEMPRE** valide que planos semestrais/anuais s√£o direcionados para o sistema modernizado
- **SEMPRE** teste cen√°rios de falha quando servi√ßos externos n√£o est√£o dispon√≠veis
- **NUNCA** ignore o tratamento de erros de conectividade

Essas regras garantem testes confi√°veis, isolados e que realmente validam o comportamento da aplica√ß√£o em cen√°rios reais, mantendo simplicidade e foco no comportamento.
